# Arc4u.Standard.gRPC

This package is targeting the first implementation of gRPC.

The support of gRPC is evolving quickly at Microsoft. We can see that it will become the first citizen communication layer in the future.
Today there are 2 implementation of gRPC:
1. Core gRPC
2. .Net implementation.

Core gRPC is maintained by gRPC (and I think this is done by Microsoft) and the .Net implementation is developped by Microsoft.

The client part in an AspNet Core can be implemented via gRPC core or [.Net implementation](https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-5.0&tabs=visual-studio).

As I started the implementation before the support by Microsoft of the AspNetCore one. [It means that this implementation is not yet used.](https://docs.microsoft.com/en-us/aspnet/core/grpc/clientfactory?view=aspnetcore-5.0)

The gRPC core was my choice because this is working on a lot of .Net version (Wpf on .Net, Uwp and Xamarin.Forms (experimental)).

We can see that the gRPC.Net implementation will be the way to use gRPC in .Net but this will be the case from .Net 6.

## Package audience.

The target of the Arc4u.Standard.gRPC package is for clients (AspNet and UIs). In a future I will adapt the code generated by the Guidance to go to the AspNet Core implementation.

Basically we have 3 parts:
- The interceptors
- The channels
- The ServiceAspect (Server side).

### Interceptors

An interceptor in gRPC is more or less like an HttpHandler in HttpClient.
This allows us to inject or manipulate the message.

We have service interceptors:
- OAuth2Interceptor
  - Is used to inject the bearer token in the metadata.
- AuthorizationInterceptor.
  - Is used to verify if a ServiceAspect attribute defines the rights.

We have one client interceptor:
- ClientErrorInterceptor
  - Transforms the gRpc error and encapsulate this in AppException (Client side)

### Channels.

By default the communication channel must be secured via TLS 1.2 for gRPC.
There is no problem at all to not use TLS but this is not a good practice. 
When you communicate with a gRPC service you have to provide a channel and gives back the certificate to use (defined by the server side).

The good news is that we can extract from the server side certificate used all the information needed.

This is what the framework does.

A IRootCertificateExtractor implementation based on the url of the service will extract the certificate information and this can be set in the channel.

The RootPemCertificates class resolves in its constructor the IRootCertificateExtractor implementation. 
This will load the public parts of the ssl and extract in a pem format.

#### UI side.

On the UI the communication with the backend is always encrypted!
The channel is created based on a TLS communication and we have to provide the pem to the channel.

```csharp
    var channel = new Channel(_rootUri.Host, _rootUri.Port, new SslCredentials(_rootPemCertificates.GetPemFor(_rootUri)));
```

#### Backend side.

On the backend side when we are not inside k8s, the communication must use TLS but inside K8s we can accept to work without encrption.
The code became.

```csharp
            var channel = _rootUri.Scheme.Equals("https", System.StringComparison.InvariantCultureIgnoreCase) ?
                            new Channel(_rootUri.Host, _rootUri.Port, new SslCredentials(_rootPemCertificates.GetPemFor(_rootUri)))
                            :
                            new Channel(_rootUri.Host, _rootUri.Port, ChannelCredentials.Insecure);
```










